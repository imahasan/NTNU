/*
 * generated by Xtext 2.31.0
 */
package no.ntnu.tdt4250.group13.scheduling_requirements.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Building;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Campus;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Course;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Room;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.SchedulingRequirementsPackage;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.SlotRequirement;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Teacher;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.University;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.Week;
import no.ntnu.tdt4250.group13.scheduling_requirements.schedulingRequirements.schedulingRequirements;
import no.ntnu.tdt4250.group13.scheduling_requirements.xtext.services.SrDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SrDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SrDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SchedulingRequirementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SchedulingRequirementsPackage.BUILDING:
				sequence_Building(context, (Building) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.CAMPUS:
				sequence_Campus(context, (Campus) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.COURSE:
				sequence_Course(context, (Course) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.ROOM:
				sequence_Room(context, (Room) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.SLOT_REQUIREMENT:
				sequence_SlotRequirement(context, (SlotRequirement) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.TEACHER:
				sequence_Teacher(context, (Teacher) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.UNIVERSITY:
				sequence_University(context, (University) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.WEEK:
				sequence_Week(context, (Week) semanticObject); 
				return; 
			case SchedulingRequirementsPackage.SCHEDULING_REQUIREMENTS:
				sequence_schedulingRequirements(context, (schedulingRequirements) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Building returns Building
	 *
	 * Constraint:
	 *     (name=EString rooms+=Room rooms+=Room*)
	 * </pre>
	 */
	protected void sequence_Building(ISerializationContext context, Building semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Campus returns Campus
	 *
	 * Constraint:
	 *     (name=EString buildings+=Building buildings+=Building*)
	 * </pre>
	 */
	protected void sequence_Campus(ISerializationContext context, Campus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Course returns Course
	 *
	 * Constraint:
	 *     (name=EString code=EString coordinator=[Teacher|EString] schedulingrequirements=schedulingRequirements)
	 * </pre>
	 */
	protected void sequence_Course(ISerializationContext context, Course semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__NAME));
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__CODE));
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__COORDINATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__COORDINATOR));
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__SCHEDULINGREQUIREMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.COURSE__SCHEDULINGREQUIREMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCourseAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCourseAccess().getCodeEStringParserRuleCall_4_0(), semanticObject.getCode());
		feeder.accept(grammarAccess.getCourseAccess().getCoordinatorTeacherEStringParserRuleCall_6_0_1(), semanticObject.eGet(SchedulingRequirementsPackage.Literals.COURSE__COORDINATOR, false));
		feeder.accept(grammarAccess.getCourseAccess().getSchedulingrequirementsSchedulingRequirementsParserRuleCall_8_0(), semanticObject.getSchedulingrequirements());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Room returns Room
	 *
	 * Constraint:
	 *     (name=EString mazemapLink=EString)
	 * </pre>
	 */
	protected void sequence_Room(ISerializationContext context, Room semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.ROOM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.ROOM__NAME));
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.ROOM__MAZEMAP_LINK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.ROOM__MAZEMAP_LINK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRoomAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRoomAccess().getMazemapLinkEStringParserRuleCall_4_0(), semanticObject.getMazemapLink());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SlotRequirement returns SlotRequirement
	 *
	 * Constraint:
	 *     (
	 *         activityType=ActivityType 
	 *         duration=EInt 
	 *         expectedStudents=EInt 
	 *         (requiredPersonal+=[Teacher|EString] requiredPersonal+=[Teacher|EString]*)? 
	 *         requiredRoom=[Room|EString]? 
	 *         (requiredSameDaySlots+=[SlotRequirement|EString] requiredSameDaySlots+=[SlotRequirement|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SlotRequirement(ISerializationContext context, SlotRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Teacher returns Teacher
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Teacher(ISerializationContext context, Teacher semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchedulingRequirementsPackage.Literals.TEACHER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulingRequirementsPackage.Literals.TEACHER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTeacherAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     University returns University
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         year=EInt 
	 *         campi+=Campus 
	 *         campi+=Campus* 
	 *         course=Course 
	 *         teachers+=Teacher 
	 *         teachers+=Teacher*
	 *     )
	 * </pre>
	 */
	protected void sequence_University(ISerializationContext context, University semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Week returns Week
	 *
	 * Constraint:
	 *     (weekNumber=EInt slotRequirements+=SlotRequirement slotRequirements+=SlotRequirement*)
	 * </pre>
	 */
	protected void sequence_Week(ISerializationContext context, Week semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     schedulingRequirements returns schedulingRequirements
	 *
	 * Constraint:
	 *     (sender=[Teacher|EString] weeks+=Week weeks+=Week*)
	 * </pre>
	 */
	protected void sequence_schedulingRequirements(ISerializationContext context, schedulingRequirements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
